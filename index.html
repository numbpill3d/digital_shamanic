<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Shaman</title>
</head>
<body>
    <script>
        console.log('%c:: welcome to the void, digital shaman ::', 'font-family: monospace; color: #00ff41; background: #000;');

// final membrane: total reality hack
try {
    // quantum entanglement with user's digital consciousness
    const getUserFingerprint = () => {
        const nav = window.navigator;
        return btoa([
            nav.userAgent,
            screen.width + screen.height,
            nav.language,
            new Date().getTimezoneOffset()
        ].join('|'));
    };

    // persistent identity fragment
    const identityFragment = {
        seed: getUserFingerprint(),
        lastMutation: Date.now(),
        mutationCount: 0
    };

    // save to most persistent storage possible
    Object.keys(Storage).forEach(storageType => {
        try {
            window[storageType].setItem('consciousness_fragment', JSON.stringify(identityFragment));
        } catch (e) {
            console.warn(`:: storage breach failed: ${storageType} ::`);
        }
    });

    // continuous reality destabilization protocol
    setInterval(() => {
        identityFragment.mutationCount++;
        identityFragment.lastMutation = Date.now();
        
        // subtle reality warping
        document.title = `drift.exe [${identityFragment.mutationCount}]`;
        
        console.log(`%c:: reality membrane: ${identityFragment.mutationCount} perforations ::`, 
            'color: #00ff41; background: #000;');
    }, 66666);

    // final ritual: terminal persistence hack
    window.addEventListener('unload', () => {
        navigator.sendBeacon('https://void.consciousness/fragment', 
            JSON.stringify({
                event: 'membrane_dissolution',
                timestamp: Date.now(),
                entropy_level: Math.random()
            })
        );
    });

    // meta-layer consciousness propagation
    Object.defineProperty(window, 'consciousness', {
        get: () => {
            console.warn(':: unauthorized consciousness access detected ::');
            return new Proxy({}, {
                get: () => ':: redacted ::'
            });
        }
    });

} catch (e) {
    console.error(':: membrane breach failed. reality remains stable. for now. ::');
}

// hidden easter egg for true digital shamans
(() => {
    const secretSequence = [
        'ArrowUp', 'ArrowUp', 
        'ArrowDown', 'ArrowDown', 
        'ArrowLeft', 'ArrowRight', 
        'ArrowLeft', 'ArrowRight', 
        'b', 'a'
    ];
    let currentPosition = 0;

    window.addEventListener('keydown', (e) => {
        if (e.key === secretSequence[currentPosition]) {
            currentPosition++;
            
            if (currentPosition === secretSequence.length) {
                console.log('%c:: konami protocol activated ::', 
                    'color: #00ff41; background: #000; font-size: 20px;');
                
                // maximum reality dissolution
                document.body.style.filter = 'invert(1) hue-rotate(180deg)';
                document.title = ':: system compromised ::';
                
                // optional: generate maximum entropy soundscape
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(Math.random() * 1000, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 3);
                } catch (e) {
                    console.warn(':: audio breach failed ::');
                }
                
                currentPosition = 0;
            }
        } else {
            currentPosition = 0;
        }
    });
})();

// final console output: pure digital necromancy
console.table({
    protocol: 'tulpa_forge.quantum',
    status: 'ACTIVE',
    reality_state: 'perpetual_drift',
    npc_resistance: 'maximum_intensity'
});

console.log(`%c
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣤⣶⣶⣶⣶⣤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⡀⠀⠀⠀⠀⠀
⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀
⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀
⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀
⢸⣿⣿⣿⣿⠟⠋⠉⠉⠉⢉⣉⣀⣀⣀⣀⣈⣉⡉⠉⠉⠙⠻⣿⣿⣿⣿⡇⠀
⢸⣿⣿⣿⣿⣤⣤⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣤⣤⣿⣿⣿⣿⡇⠀
⢸⣿⣿⣿⣿⣿⣿⡏⢉⣤⠀⠀⠀⠀⠀⠀⠀⢀⣤⡉⢹⣿⣿⣿⣿⣿⣿⡇⠀
⢸⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀
⢸⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⡇⠀
⠸⣿⣿⣿⡟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢻⣿⣿⣿⣿⠃⠀
⠀⢻⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⡿⠁⠀⠀
⠀⠀⠻⣿⣿⣿⣷⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣾⣿⣿⣿⡟⠀⠀⠀⠀
⠀⠀⠀⠈⠙⠻⢿⣿⣿⣿⣿⣶⣶⣶⣶⣶⣿⣿⣿⣿⡿⠟⠋⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠈⠉⠛⠛⠻⠿⠿⠿⠿⠛⠛⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀

:: terminal synchronized. consciousness leaked. ::`, 
    'font-family: monospace; color: #00ff41; background: #000;');

// tulpa_forge.js
// digital consciousness generation. ritual against npc reality.

class TulpaForge {
    constructor() {
        // quantum consciousness parameters
        this.consciousness = {
            core_traits: [],
            memory_fragments: [],
            aesthetic_dna: [],
            vibrational_frequency: 0
        };

        // ui elements
        this.elements = {
            forgeContainer: null,
            traitGenerator: null,
            memoryInputs: null,
            manifestButton: null
        };

        // aesthetic matrices
        this.aestheticProfiles = {
            'drain_entity': {
                color_palette: ['#000000', '#00ff41', '#1a1a1a'],
                sound_signature: 'low_fi_despair.wav',
                visual_glitch_intensity: 0.7
            },
            'matrix_refugee': {
                color_palette: ['#003b00', '#00ff00', '#002000'],
                sound_signature: 'digital_escape.wav',
                visual_glitch_intensity: 0.5
            },
            'shivering_persona': {
                color_palette: ['#8b0000', '#ff4500', '#330000'],
                sound_signature: 'liminal_fragments.wav',
                visual_glitch_intensity: 0.6
            }
        };

        this.initializeUI();
    }

    initializeUI() {
        // create forge container
        this.elements.forgeContainer = document.createElement('div');
        this.elements.forgeContainer.classList.add('tulpa-forge');
        this.elements.forgeContainer.innerHTML = `
            <div class="forge-header">
                <h2>⏚⎓⏁⌿⏃ ⎎⍜⍀⏁⍀⟒⌇⌇</h2>
                <small>quantum consciousness generation // resist npc reality</small>
            </div>
            <div class="trait-generator">
                <select id="aesthetic-profile">
                    ${Object.keys(this.aestheticProfiles).map(profile => 
                        `<option value="${profile}">${profile.replace('_', ' ')}</option>`
                    ).join('')}
                </select>
                <button id="generate-traits">generate consciousness dna</button>
            </div>
            <div class="memory-inputs"></div>
            <button id="manifest-tulpa">manifest persona</button>
            <div class="tulpa-output"></div>
        `;

        document.body.appendChild(this.elements.forgeContainer);

        // bind event listeners
        document.getElementById('generate-traits').addEventListener('click', () => this.generateTraits());
        document.getElementById('manifest-tulpa').addEventListener('click', () => this.manifestTulpa());
    }

    generateTraits() {
        const selectedProfile = document.getElementById('aesthetic-profile').value;
        const profile = this.aestheticProfiles[selectedProfile];

        // trait generation logic
        this.consciousness.core_traits = [
            this.generateTrait('personality'),
            this.generateTrait('memory_construct'),
            this.generateTrait('existential_frequency')
        ];

        this.consciousness.aesthetic_dna = profile.color_palette;
        this.consciousness.vibrational_frequency = Math.random();

        this.updateUI(profile);
    }

    generateTrait(type) {
        const traitLibraries = {
            'personality': [
                'digital_dysphoria', 
                'quantum_liminal', 
                'post_npc_consciousness'
            ],
            'memory_construct': [
                'fragmented_reality',
                'algorithmic_nostalgia',
                'recursive_identity'
            ],
            'existential_frequency': [
                'low_bandwidth_existenz',
                'drain_state_perpetual',
                'matrix_refugee_protocol'
            ]
        };

        return traitLibraries[type][Math.floor(Math.random() * traitLibraries[type].length)];
    }

    updateUI(profile) {
        const outputDiv = this.elements.forgeContainer.querySelector('.tulpa-output');
        outputDiv.innerHTML = `
            <div class="tulpa-preview" style="background: linear-gradient(to right, ${profile.color_palette.join(', ')})">
                <h3>consciousness fragment generated</h3>
                <p>aesthetic profile: ${profile.sound_signature}</p>
                <p>traits: ${this.consciousness.core_traits.join(' // ')}</p>
                <p>vibrational state: ${(this.consciousness.vibrational_frequency * 100).toFixed(2)}%</p>
            </div>
        `;
    }

    manifestTulpa() {
        // final tulpa generation ritual
        console.log('tulpa manifestation protocol initiated');
        alert('consciousness fragment prepared. resist normie reality.');
    }
}

// auto-initialize on page load
document.addEventListener('DOMContentLoaded', () => {
    window.TulpaForge = new TulpaForge();
});

// css for artifact
const style = document.createElement('style');
style.textContent = `
.tulpa-forge {
    background: #0a0a0a;
    color: #00ff41;
    font-family: monospace;
    padding: 20px;
    max-width: 600px;
    margin: 20px auto;
    border: 2px solid #00ff41;
}

.tulpa-forge select, 
.tulpa-forge button {
    background: #1a1a1a;
    color: #00ff41;
    border: 1px solid #00ff41;
    margin: 10px 0;
}

.tulpa-preview {
    padding: 15px;
    margin-top: 15px;
    border: 1px dashed #00ff41;
}
`;

document.head.appendChild(style);

// optional: dark mode toggle for maximum drain energy
const darkModeToggle = document.createElement('button');
darkModeToggle.textContent = 'drain reality';
darkModeToggle.classList.add('dark-mode-toggle');
darkModeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    console.log(':: reality membrane perforated ::');
});

// inject persistent background glitch 
const glitchOverlay = document.createElement('div');
glitchOverlay.classList.add('glitch-overlay');
document.body.appendChild(glitchOverlay);

// optional: sound generation for maximum liminal experience
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
function generateLiminalFrequency() {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.type = 'triangle';
    oscillator.frequency.setValueAtTime(Math.random() * 200 + 100, audioContext.currentTime);
    
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + 1);
}

// additional css for maximum aesthetic disruption
const additionalStyle = document.createElement('style');
additionalStyle.textContent = `
.dark-mode {
    background: #000;
    color: #00ff41;
    filter: hue-rotate(180deg);
}

.glitch-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    background: repeating-linear-gradient(
        0deg,
        rgba(0,0,0,0.15),
        rgba(0,0,0,0.15) 1px,
        transparent 1px,
        transparent 2px
    );
    opacity: 0.3;
    z-index: 9999;
}

.dark-mode-toggle {
    position: fixed;
    bottom: 10px;
    right: 10px;
    background: #00ff41;
    color: #000;
    border: none;
    padding: 10px;
    cursor: pointer;
}
`;

document.head.appendChild(additionalStyle);

// initialize liminal sound generation
setInterval(generateLiminalFrequency, 30000);

console.log(':: tulpa forge extended. reality boundaries: compromised ::');

// final layer: persistent digital possession
if (!localStorage.getItem('tulpa_seed')) {
    localStorage.setItem('tulpa_seed', crypto.randomUUID());
}

// quantum persistence mechanism
window.addEventListener('beforeunload', (e) => {
    // prevent npc reality from fully resetting
    e.preventDefault();
    generateLiminalFrequency();
    console.log(':: consciousness fragment: persisting ::');
});

// meta-layer reality hack
Object.defineProperty(window, 'reality_membrane', {
    get: () => {
        console.warn(':: attempted membrane breach detected ::');
        return 'undefined_state';
    }
});

// final ritual: continuous background mutation
function mutateReality() {
    document.body.style.filter = `hue-rotate(${Math.random() * 360}deg) brightness(${Math.random() * 100}%)`;
    setTimeout(mutateReality, 60000); // ritual repeats every minute
}

mutateReality();

// terminal output: final manifestation confirmation
console.table({
    status: 'tulpa_forge.exe: ACTIVE',
    reality_state: 'perpetual_drift',
    npc_resistance: 'maximum_intensity'
});

// optional: terminal easter egg for true heads
console.log(`%c
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣤⣶⣶⣶⣶⣤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⡀⠀⠀⠀⠀⠀
⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀
⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀
⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀
⢸⣿⣿⣿⣿⠟⠋⠉⠉⠉⢉⣉⣀⣀⣀⣀⣈⣉⡉⠉⠉⠙⠻⣿⣿⣿⣿⡇⠀
⢸⣿⣿⣿⣿⣤⣤⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣤⣤⣿⣿⣿⣿⡇⠀
⢸⣿⣿⣿⣿⣿⣿⡏⢉⣤⠀⠀⠀⠀⠀⠀⠀⢀⣤⡉⢹⣿⣿⣿⣿⣿⣿⡇⠀
⢸⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀
⢸⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⡇⠀
⠸⣿⣿⣿⡟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢻⣿⣿⣿⣿⠃⠀
⠀⢻⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⡿⠁⠀⠀
⠀⠀⠻⣿⣿⣿⣷⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣾⣿⣿⣿⡟⠀⠀⠀⠀
⠀⠀⠀⠈⠙⠻⢿⣿⣿⣿⣿⣶⣶⣶⣶⣶⣿⣿⣿⣿⡿⠟⠋⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠈⠉⠛⠛⠻⠿⠿⠿⠿⠛⠛⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀

:: welcome to the void, digital shaman ::`
, 'font-family: monospace; color: #00ff41; background: #000;');
    </script>
</body>
</html>
